\section{Описание}
Требуется написать реализацию алгоритма поразрядной сортировки.

Идея сортировки заключается в разбиении сортируемых элементов на разряды. Затем выполняется устойчивая сортировка подсчетом для каждого разряда. При этом, для строк подходит версия MSD(Most Significant Digit) - сортировка начинается от самого старшего разряда. Для чисел же нужно использовать LSD-версию(Least Significant Digit). В данной версии, сортировка начинается от самого младшего разряда.

\pagebreak

\section{Исходный код}
Jopa
\begin{lstlisting}[language=C]
void sort(TElement*, int& amount_of_elems);
int main(int argc, char *argv[])
{
    int size_of_array = 1; // default value
    int amount_of_elems = 0;
    TElement* array = new TElement[size_of_array]; // array of elems
    while(1)
    {
        char ch = getchar();
        if(ch == EOF || ch == '\0')
            break;
        else
            ungetc(ch, stdin);
        if(amount_of_elems == size_of_array)
        {
            TElement* tmp_buffer = new TElement[size_of_array];
            memcpy(tmp_buffer, array, size_of_array*sizeof(TElement));
            array = new TElement[size_of_array * 2];
            memcpy(array, tmp_buffer, size_of_array*sizeof(TElement));
            size_of_array *= 2;
            delete[] tmp_buffer;
        }
        scanf("%s", array[amount_of_elems].Buffer);
        scanf("%llu", &array[amount_of_elems].n);
        ++amount_of_elems;
        getchar();
    }
    sort(array, amount_of_elems);
    for(int i = 0; i < amount_of_elems; ++i)
    {
        printf("%s\t", array[i].Buffer);
        printf("%llu\n", array[i].n);
    }
    delete[] array;
    return 0;
}
void sort(TElement* array, int& amount_of_elems)
{
    const int radix = 16;
    const int strLen = 32;
    TElement* A = new TElement [amount_of_elems];
    for(int digit = strLen - 1; digit >= 0; --digit)
    {
        int C[radix] = {0};
        for(int i = 0; i < amount_of_elems; ++i)
        {
            A[i] = array[i];
            int c = array[i].Buffer[digit];
            if (c >= '0' && c <= '9') c = c - '0';
            else c = c - 'a' + 10; // According to ASCII table
            ++C[c];
        }
        for(int i = 1; i < radix; ++i)
            C[i] = C[i] + C[i - 1];
        for(int i = amount_of_elems - 1; i >= 0; --i)
        {
            TElement val = A[i];
            int c = A[i].Buffer[digit];
            if (c >= '0' && c <= '9') c = c - '0';
            else c = c - 'a' + 10; // According to ASCII table
            int position = C[c] - 1;
            array[position] = val;
            --C[c];
        }
    }
    delete[] A;
}

	
\end{lstlisting}


\section{Консоль}
\begin{alltt}
a.kukhticev$ gcc -pedantic -Wall -std=c99 -Werror -Wno-sign-compare -lm da10.c -o da10 --some_long_argument=true
a.kukhticev$ cat test1 
87	a
13	b
89	c
13	d
a.kukhticev$ ./da10 < test1 
13	b
13	d
87	a
89	c
\end{alltt}
\pagebreak

