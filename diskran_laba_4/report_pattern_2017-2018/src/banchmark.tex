\section{Тест производительности}
Для оценки производительности алгоритма КМП я решил сравнить его с наивным алгоритмом поиска подстроки в строке. Его суть заключается в сравнении всех элементов шаблона с текстом. При несовпадении мы производим сдвиг шаблона на еденицу и повторяем все шаги заново.
Ниже приведен листинг бенчмарка:
\textbf{benchmark.cpp}
\begin{lstlisting}[language=C]
#include <iostream>
#include <string>
void SloySort(const std::string& pattern, const std::string& text)
{
    for(int i = 0; i < text.size() - pattern.size(); ++i)
    {
        int k = i;
        for(int j = 0; j < pattern.size(); ++j)
        {
            if(text[k] == pattern[j])
                ++k;
            else break;
        }
        if(k == i + pattern.size())
            std::cout<<"Match\n";
    }
}
int main()
{
    std::string pattern;
    std::string text;
    long val;
    while(std::cin.get() != '\n')
    {
        std::cin.unget();
        std::cin>>val;
        pattern += std::to_string(val) + " ";
    }
    while(pattern.back() == ' ')
        pattern.pop_back();
    while(std::cin>>val)
    {
        text += std::to_string(val);
        int ch;
        ch = std::cin.get();
        if(ch == ' ')	text += " ";
        else	text += "\n";
    }
    SloySort(pattern, text);
    return 0;
}
\end{lstlisting}
\begin{alltt}
alex$head 01.t
77 71 69 93
55 82 56 69100 82 95 8868 73 81 5654 77 69 9755 85 69 5382 67 79 6388 78 84 7165 55 54 9077 65 57 5390 82 94 8093 71 92 6066 58 96 5451 66 64 8476 54 58 8060 67 80 6256 85 100 5579 61 83 5152 93 94 7774 79 98 5454 82 55 6970 51 58 9089 99 95 69100 92 76 5069 55 93 6552 74 51 9890 79 88 7862 96 75 6562 88 58 7780 86 94 8065 75 60 9381 80 67 9851 94 56 8487 55 66 9371 80 61 6497 92 83 9190 81 92 69100 91 65 7182 62 90 6979 97 87 7196 73 61 5582 74 86 7461 82 54 6750 71 52 7983 75 52 7261 58 71 10055 58 54 93100 78 52 6581 96 66 9957 63 56 5761 98 53 8757 100 91 9872 61 86 8488 90 58 6087 87 63 8970 85 78 5364 60 81 10057 88 85 6173 55 71 5776 72 91 7886 86 55 8852 52 79 9272 76 92 6961 71 85 5454 84 56 9195 77 79 5360 74 95 7684 71 86 9282 66 77 5156 83 75 8883 62 70 5259 82 60 7476 91 90 
alex$make
g++ -o da_4 -pg -std=c++11 -pedantic -Wall -Werror -Wno-sign-compare -Wno-long-long main.cpp -lm
alex$time ./*4 < 01.t > res*

real    0m20.619s
user    0m20.568s
sys     0m0.040s
alex$g++ -std=c++11 bench*
alex$time ./a.out < 01.t > res*

real    0m23.504s
user    0m23.208s
sys     0m0.280s
alex$
\end{alltt}
Из теста производительности видно, что КМП работает быстрее, чем наивный алгоритм. Однако в нашем случае разница не значительна. Дело в том, что КМП выигрывает у самого просто алгоритма, когда несовпадение в образце происходит ближе к его концу. Время работы будет $O(m*n)$, тогда как КМП алгоритм будет линейным -- $O(m + n)$. В данном тесте я использовал "хорошие" данные -- то есть несовпадение в тексте и образце происходило не в самом конце. При "плохих" входных данных алгоритм КМП будет значительно быстрее наивного. Однако и в нашем случае мы видим, что алгоритм Кнутта-Морриса-Пратта производительней.
\pagebreak
